# -*- coding: utf-8 -*-
"""CPU.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_9ZQGBhV91V1wS0yOuqV9VaJqXQ0kcj5
"""

# Simple CPU Simulator (improved & safe)

NUM_REGS = 4
MEM_SIZE = 256
MAX_CYCLES = 1000  # safety guard to prevent infinite loops

memory = [0] * MEM_SIZE           # 256-byte memory
R = [0] * NUM_REGS                # General registers R0..R3
PC = 0                            # Program Counter (instruction index)
Z = False                         # Zero flag
running = True

# Program: tuples (opcode, arg1, arg2?) - semantics depend on opcode
program = [
    ("MOV", 0, 5),      # R0 = 5
    ("MOV", 1, 10),     # R1 = 10
    ("ADD", 0, 1),      # R0 = R0 + R1 -> 15
    ("STORE", 0, 20),   # memory[20] = R0
    ("LOAD", 2, 20),    # R2 = memory[20]
    ("SUB", 2, 1),      # R2 = R2 - R1 -> 5
    ("JZ", 10),         # if Z true -> jump to index 10
    ("MOV", 3, 99),     # R3 = 99
    ("HLT",)            # stop execution
]

def safe_fetch(pc):
    """Return the instruction at pc or raise IndexError with a helpful message."""
    if pc < 0 or pc >= len(program):
        raise IndexError(f"PC out of range: {pc}")
    return program[pc]

def validate_register_index(idx):
    if not (0 <= idx < NUM_REGS):
        raise IndexError(f"Register index out of range: R{idx}")

def validate_memory_address(addr):
    if not (0 <= addr < MEM_SIZE):
        raise IndexError(f"Memory address out of range: {addr}")

print("==== START EXECUTION ====\n")
cycle = 0

while running:
    if cycle >= MAX_CYCLES:
        raise RuntimeError(f"Exceeded max cycle limit ({MAX_CYCLES}). Possible infinite loop.")
    instr = safe_fetch(PC)
    op = instr[0]

    # Trace: fetch
    print(f"[Cycle {cycle}] FETCH: PC={PC} IR={instr}  Registers={R}  Z={int(Z)}")

    # Decode & Execute
    if op == "MOV":
        # MOV reg, immediate
        if len(instr) != 3:
            raise ValueError("MOV expects 2 operands: (reg, imm)")
        reg, imm = instr[1], instr[2]
        validate_register_index(reg)
        R[reg] = imm
        Z = (R[reg] == 0)
        print(f"    EXECUTE: MOV R{reg} <- {imm}")

    elif op == "ADD":
        # ADD rd, rs
        if len(instr) != 3:
            raise ValueError("ADD expects 2 operands: (rd, rs)")
        rd, rs = instr[1], instr[2]
        validate_register_index(rd); validate_register_index(rs)
        R[rd] = R[rd] + R[rs]
        Z = (R[rd] == 0)
        print(f"    EXECUTE: ADD R{rd} <- R{rd} + R{rs} = {R[rd]}")

    elif op == "SUB":
        # SUB rd, rs
        if len(instr) != 3:
            raise ValueError("SUB expects 2 operands: (rd, rs)")
        rd, rs = instr[1], instr[2]
        validate_register_index(rd); validate_register_index(rs)
        R[rd] = R[rd] - R[rs]
        Z = (R[rd] == 0)
        print(f"    EXECUTE: SUB R{rd} <- R{rd} - R{rs} = {R[rd]}")

    elif op == "STORE":
        # STORE reg, address
        if len(instr) != 3:
            raise ValueError("STORE expects 2 operands: (reg, addr)")
        reg, addr = instr[1], instr[2]
        validate_register_index(reg); validate_memory_address(addr)
        memory[addr] = R[reg]
        print(f"    EXECUTE: STORE memory[{addr}] <- R{reg} ({R[reg]})")

    elif op == "LOAD":
        # LOAD reg, address
        if len(instr) != 3:
            raise ValueError("LOAD expects 2 operands: (reg, addr)")
        reg, addr = instr[1], instr[2]
        validate_register_index(reg); validate_memory_address(addr)
        R[reg] = memory[addr]
        Z = (R[reg] == 0)
        print(f"    EXECUTE: LOAD R{reg} <- memory[{addr}] ({R[reg]})")

    elif op == "JMP":
        # JMP target  (unconditional)
        if len(instr) != 2:
            raise ValueError("JMP expects 1 operand: (target)")
        target = instr[1]
        if not (0 <= target < len(program)):
            raise IndexError(f"JMP target out of range: {target}")
        print(f"    EXECUTE: JMP to {target}")
        PC = target
        cycle += 1
        continue  # skip PC += 1

    elif op == "JZ":
        # JZ target (jump if Z == 1)
        if len(instr) != 2:
            raise ValueError("JZ expects 1 operand: (target)")
        target = instr[1]
        if Z:
            if not (0 <= target < len(program)):
                raise IndexError(f"JZ target out of range: {target}")
            print(f"    EXECUTE: JZ taken -> PC = {target} (Z=1)")
            PC = target
            cycle += 1
            continue
        else:
            print("    EXECUTE: JZ not taken (Z=0)")

    elif op == "HLT":
        print("    EXECUTE: HLT - stopping execution.")
        running = False

    else:
        raise ValueError(f"Unknown opcode: {op}")

    # default: move to next instruction
    PC += 1
    cycle += 1
    print()  # blank line for readability

print("\n==== EXECUTION FINISHED ====\n")
print("Final Register Values:", R)
print("Memory[20]:", memory[20])